% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cv_trendfilter.R
\name{cv_trendfilter}
\alias{cv_trendfilter}
\title{Leave-vth-out cross validation for trendfilter}
\usage{
cv_trendfilter(
  y,
  x = seq_along(y),
  weights = rep(1, n),
  k = 3L,
  error_measure = c("deviance", "mse", "mae"),
  nfolds = 5L,
  lambda = NULL,
  ...
)
}
\arguments{
\item{y}{vector of observations of length \code{n}}

\item{x}{vector of positions at which the \code{y} have been observed, defaults
to \code{1:n}. These should be in increasing order, but will be sorted if
necessary.}

\item{weights}{vector of weights for the observations, defaults to \code{rep(1, n)}.
Note that internally, these are rescaled to sum to 1.}

\item{k}{Integer. Degree of the piecewise polynomial curve to be
estimated. For example, \code{k = 0} corresponds to a piecewise constant
curve.}

\item{error_measure}{Metric used to calculate cross validation scores. May
be \code{mse}, \code{mae}, or \code{deviance}.}

\item{nfolds}{Integer. The number of folds to use. For leave-vth-out cross
validation, every vth \code{y} value and its corresponding position (and weight)
are placed into the same fold. The first and last observations are not
assigned to any folds. This value must be at least 2. As an example, with
15 data points and \code{nfolds = 4}, the points are assigned to folds in the
following way:
\deqn{
  0 \; 1 \; 2 \; 3 \; 4 \; 1 \; 2 \; 3 \;  4 \; 1 \; 2 \; 3 \; 4 \; 1 \; 0
  }{0 1 2 3 4 1 2 3 4 1 2 3 4 1 0} where 0 indicates no assignment.
Therefore, the folds are not random and running \code{cv_trendfilter()} twice
will give the same result.}

\item{lambda}{Vector. A user supplied sequence of tuning parameters which
determines the balance between data fidelity and smoothness of the
estimated curve; larger \code{lambda} results in a smoother estimate. The
default, \code{NULL} results in an automatic computation based on \code{nlambda},
the largest value of \code{lambda} that would result in a maximally smooth
estimate, and \code{lambda_min_ratio}. Supplying a value of \code{lambda} overrides
this behaviour. It is likely better to supply a
decreasing sequence of \code{lambda} values than a single (small) value. If
supplied, the user-defined \code{lambda} sequence is automatically sorted in
decreasing order.}

\item{...}{additional parameters passed along to \code{\link[=trendfilter]{trendfilter()}}.}
}
\value{
An object with S3 class \code{"cv_trendfilter"}. Among the list components:
\itemize{
\item \code{full_fit} An object with S3 class \code{"trendfilter"}, estimated with all
\code{y} and \code{lambda}
\item \code{cv_scores} leave-vth-out cross validation scores
\item \code{cv_se} leave-vth-out cross validation standard error
\item \code{lambda_min} lambda which achieved the optimal cross validation score
\item \code{lambda_1se} lambda that gives the optimal cross validation score
within one standard error.
\item \code{lambda} the value of \code{lambda} used in the algorithm.
}
}
\description{
Leave-vth-out cross validation for trendfilter
}
\examples{
x <- 1:100 / 101 * 2 * pi
y <- sin(x) + .2 * rnorm(100)
cv <- cv_trendfilter(y, x)
}
