% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/methods-cv.R
\name{predict.cv_trendfilter}
\alias{predict.cv_trendfilter}
\title{Predict with trendfilter at new (interior) design points
#'}
\usage{
\method{predict}{cv_trendfilter}(object, newx = NULL, which_lambda = c("lambda_min", "lambda_1se"), ...)
}
\arguments{
\item{object}{result of \code{cv_trendfilter()} of class \code{cv_trendfilter}}

\item{newx}{numeric vector of new design points at which to evaluate the. The
default, \code{NULL} returns the estimates at the original \code{x} values.}

\item{which_lambda}{select which solutions to show. If provided a
vector of \code{lambda} values, the corresponding \eqn{\theta} estimates will be
plotted. If a string, it must be either one of \code{lambda_min}, or \code{lambda_1se}.
\itemize{
\item \code{lambda_min}: plot the estimates corresponding to the lambda
that minimizes the cross validation score.
\item \code{lambda_1se}: plot estimates corresponding to the largest lambda whose
corresponding CV score is within 1 standard error of the
minimal cross validation score.
\item If NULL, all estimated \eqn{\theta}'s are plotted (at \code{newx}).
}}

\item{...}{additional arguments passed to \code{predict.trendfilter()}}
}
\value{
A vector or matrix of predictions.
}
\description{
Predict with trendfilter at new (interior) design points
#'
}
\examples{
x <- 1:100 / 101 * 2 * pi
y <- sin(x) + .2 * rnorm(100)
cv <- cv_trendfilter(y, x, nlambda = 20L)
p <- predict(cv)
p <- predict(cv, which_lambda = cv$lambda[1])
p <- predict(cv, which_lambda = "lambda_1se")
p <- predict(cv, which_lambda = NULL)
plot(y)
matlines(p, lty = 2)
}
