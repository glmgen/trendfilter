% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/methods-cv.R
\name{predict.cv_trendfilter}
\alias{predict.cv_trendfilter}
\title{Predict}
\usage{
\method{predict}{cv_trendfilter}(object, newx = NULL, which_lambda = c("lambda.min", "lambda.1se"), ...)
}
\arguments{
\item{object}{result of cross validation of type `cv_poisson_rt`}

\item{newx}{numeric vector of new design points at which to evaluate the. The
default, `NULL` returns the estimates at the original `x` values.}

\item{which_lambda}{Select which lambdas from the object to use. If not
  provided, all Rt's are returned. Note that new lambdas not originally
  used in the estimation procedure may be provided, but the results will be
  calculated by linearly interpolating the estimated Rt's.

  The strings `lambda.min` or `lambda.1se` are allowed to choose either
  the lambda that minimizes the cross validation score or the largest lambda
  whose corresponding cross validation score is within 1 standard error of
  the minimal cross validation score.}

\item{...}{additional arguments passed to `predict.trendfilter()`}
}
\value{
A vector or matrix of predictions.
}
\description{
Given an object of class `poisson_rt` produced with [estimate_rt()],
calculate predicted observed cases for the estimated Rt values.
Note: This function is not intended for "new x" or to produce forecasts, but
rather to examine how Rt relates to observables.
}
\examples{
x <- 1:100 / 101 * 2 * pi
y <- sin(x) + .2 * rnorm(100)
cv <- cv_trendfilter(y, x, nlambda = 20L)
p <- predict(cv)
p <- predict(cv, which_lambda = cv$lambda[1])
p <- predict(cv, which_lambda = "lambda.1se")
p <- predict(cv, which_lambda = NULL)
plot(y)
matlines(p, lty = 2)
}
