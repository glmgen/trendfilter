% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/trendfilter.R
\name{trendfilter}
\alias{trendfilter}
\title{Estimate the trendfilter}
\usage{
trendfilter(
  y,
  x = seq_along(y),
  weights = rep(1, n),
  k = 2L,
  family = c("gaussian", "logistic", "poisson"),
  method = c("admm", "pdip", "hybrid"),
  lambda = NULL,
  nlambda = 50L,
  lambda_max = NULL,
  lambda_min = NULL,
  lambda_min_ratio = 1e-05,
  control = trendfilter_control_list()
)
}
\arguments{
\item{y}{vector of observations of length \code{n}}

\item{x}{vector of positions at which the \code{y} have been observed, defaults
to \code{1:n}. These should be in increasing order, but will be sorted if
necessary.}

\item{weights}{vector of weights for the observations, defaults to \code{rep(1, n)}.
Note that internally, these are rescaled to sum to 1.}

\item{k}{Integer. Degree of the piecewise polynomial curve to be
estimated. For example, \code{k = 0} corresponds to a piecewise constant
curve.}

\item{family}{Character or function. Specifies the loss function
to use. Valid options are:
\itemize{
\item \code{"gaussian"} - least squares loss (the default),
\item \code{"binomial"} - logistic loss (classification),
\item \code{"poisson"}  - Poisson loss for count data
}

For any other type, a valid \code{\link[stats:family]{stats::family()}} object may be passed. Note
that these will generally be much slower to estimate than the built-in
options passed as strings. So for example, \code{family = "gaussian"} and
\code{family = gaussian()} will produce the same results, but the first
will be much faster.character.}

\item{method}{Character. Specifies the estimation algorithm to use.}

\item{lambda}{Vector. A user supplied sequence of tuning parameters which
determines the balance between data fidelity and smoothness of the
estimated curve; larger \code{lambda} results in a smoother estimate. The
default, \code{NULL} results in an automatic computation based on \code{nlambda},
the largest value of \code{lambda} that would result in a maximally smooth
estimate, and \code{lambda_min_ratio}. Supplying a value of \code{lambda} overrides
this behaviour. It is likely better to supply a
decreasing sequence of \code{lambda} values than a single (small) value. If
supplied, the user-defined \code{lambda} sequence is automatically sorted in
decreasing order.}

\item{nlambda}{Integer. Number of lambda values to use in the sequence.}

\item{lambda_max}{Optional value for the largest \code{lambda} to use.}

\item{lambda_min}{Optional value for the smallest \code{lambda} to use (> 0).}

\item{lambda_min_ratio}{If neither \code{lambda} nor \code{lambda_min} is specified,
\code{lambda_min = lambda_max * lambda_min_ratio}.
A very small value will lead to the solution \code{theta = y} (for the Gaussian
loss). This argument has no effect if there is a user-defined \code{lambda}
sequence.}

\item{control}{A list of control parameters for the estimation algorithm.
See the constructor \code{trendfilter_control_list()}.}
}
\value{
An object with S3 class \code{trendfilter}. Among the list components:
\itemize{
\item \code{y} the input data.
\item \code{x} the vector of positions at which the data have been observed.
\item \code{weights} the vector of observation weights
\item \code{theta} the estimated curve evaluated at \code{x}. This is a matrix with
each column corresponding to one value of \code{lambda}.
\item \code{lambda} the values of \code{lambda} actually used in the algorithm.
\item \code{korder} degree of the estimated piecewise polynomial curve.
\item \code{dof} the estimated degrees of freedom of the solution
\item \code{iters} the required number of iterations for each value of \code{lambda}.
\item \code{objective} the value of the objective function for each value of \code{lambda}.
}
}
\description{
Estimate the trendfilter
}
\examples{
x <- 1:100 / 101 * 2 * pi
y <- sin(x) + .2 * rnorm(100)
out <- trendfilter(y, x)

plot(out)
}
